<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/geist@1.7.0/dist/fonts/geist-pixel/GeistPixel-Square.woff2" as="font" type="font/woff2" crossorigin>
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/geist@1.7.0/dist/fonts/geist-pixel/GeistPixel-Grid.woff2" as="font" type="font/woff2" crossorigin>
    <title>OpenGuard</title>
    <style>
        @font-face {
            font-family: 'Geist Pixel Circle';
            src: url('https://cdn.jsdelivr.net/npm/geist@1.7.0/dist/fonts/geist-pixel/GeistPixel-Circle.woff2') format('woff2');
            font-weight: 500;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Geist Pixel Grid';
            src: url('https://cdn.jsdelivr.net/npm/geist@1.7.0/dist/fonts/geist-pixel/GeistPixel-Grid.woff2') format('woff2');
            font-weight: 500;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Geist Pixel Line';
            src: url('https://cdn.jsdelivr.net/npm/geist@1.7.0/dist/fonts/geist-pixel/GeistPixel-Line.woff2') format('woff2');
            font-weight: 500;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Geist Pixel Square';
            src: url('https://cdn.jsdelivr.net/npm/geist@1.7.0/dist/fonts/geist-pixel/GeistPixel-Square.woff2') format('woff2');
            font-weight: 500;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Geist Pixel Triangle';
            src: url('https://cdn.jsdelivr.net/npm/geist@1.7.0/dist/fonts/geist-pixel/GeistPixel-Triangle.woff2') format('woff2');
            font-weight: 500;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Geist Mono';
            src: url('https://cdn.jsdelivr.net/npm/geist@1.7.0/dist/fonts/geist-mono/GeistMono-Regular.woff2') format('woff2');
            font-weight: 400;
            font-style: normal;
            font-display: swap;
        }

        :root {
            --fg: #ededed;
            --bg: #0a0a0a;
            --font-pixel-circle: "Geist Pixel Circle", monospace;
            --font-pixel-grid: "Geist Pixel Grid", monospace;
            --font-pixel-line: "Geist Pixel Line", monospace;
            --font-pixel-square: "Geist Pixel Square", monospace;
            --font-pixel-triangle: "Geist Pixel Triangle", monospace;
            --font-mono: "Geist Mono", monospace;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font-pixel-square);
            margin: 0;
            padding: 0;
            -webkit-font-smoothing: none;
            -moz-osx-font-smoothing: grayscale;
        }

        section {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 1rem;
            position: relative;
            z-index: 10;
        }

        .container {
            width: 100%;
            max-width: 600px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        h1 {
            font-family: var(--font-pixel-grid);
            font-size: clamp(2rem, 9vw, 4.5rem);
            font-weight: 500;
            line-height: 1;
            letter-spacing: -0.06em;
            text-transform: uppercase;
            margin-bottom: 0.5rem;
            cursor: default;
            transition: opacity 0.2s, text-shadow 0.2s;
            word-wrap: normal;
            overflow-wrap: normal;
            max-width: 100%;
        }

        h1:hover {
            opacity: 0.8;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        p {
            font-size: 1rem;
            line-height: 1.6;
            opacity: 0.8;
            max-width: 480px;
            margin: 0 auto;
            padding: 0 1rem;
        }

        code {
            display: inline-block;
            padding: 1rem 1.5rem;
            border: 1px solid #333;
            background: #111;
            border-radius: 4px;
            font-size: 0.85rem;
            font-family: var(--font-mono); /* Explicitly use Geist Mono */
            color: #fff;
            user-select: all;
            cursor: pointer;
            transition: border-color 0.2s;
            -webkit-font-smoothing: antialiased; /* Better for standard mono */
            max-width: 100%;
            text-align: left;
            white-space: pre-wrap;
            word-break: normal;
            overflow-wrap: anywhere;
        }

        code:hover {
            border-color: #555;
        }

        /* --- BACKGROUND PIZZAZ --- */

        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: -1;
            opacity: 0.4;
        }

        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.2) 50%,
                rgba(0,0,0,0.2)
            );
            background-size: 100% 4px;
            z-index: 999;
            pointer-events: none;
            opacity: 0.6;
        }

        .vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(
                circle at center,
                transparent 50%,
                rgba(0,0,0,0.8) 150%
            );
            z-index: 998;
            pointer-events: none;
        }

        /* Subtle CRT Flicker Animation */
        @keyframes flicker {
            0% { opacity: 0.97; }
            5% { opacity: 0.95; }
            10% { opacity: 0.9; }
            15% { opacity: 0.95; }
            20% { opacity: 0.98; }
            25% { opacity: 0.95; }
            30% { opacity: 0.9; }
            35% { opacity: 0.96; }
            40% { opacity: 0.98; }
            45% { opacity: 0.95; }
            50% { opacity: 0.99; }
            55% { opacity: 0.93; }
            60% { opacity: 0.9; }
            65% { opacity: 0.96; }
            70% { opacity: 1; }
            75% { opacity: 0.97; }
            80% { opacity: 0.95; }
            85% { opacity: 0.92; }
            90% { opacity: 0.96; }
            95% { opacity: 0.99; }
            100% { opacity: 0.94; }
        }

        body::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: rgba(18, 16, 16, 0.1);
            opacity: 0;
            z-index: 999;
            pointer-events: none;
            animation: flicker 0.15s infinite;
        }

        /* --- ARCHITECTURE DIAGRAM --- */
        #architecture {
            background: linear-gradient(to bottom, transparent, #0a0a0a 30%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            width: 100%;
        }

        .architecture-container {
            width: 100%;
            max-width: 900px;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            gap: 2rem;
            z-index: 20;
        }

        /* Responsive Header for Flow Section */
        .flow-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 1rem;
        }

        @media (max-width: 600px) {
            .architecture-container {
                padding: 1rem;
            }

            .flow-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
            }

            #flow-wrapper {
                height: 220px !important;
            }
        }

        #architecture h2 {
            font-family: var(--font-pixel-grid);
            font-size: 2.5rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 1rem;
            opacity: 0.9;
        }

        #flow-wrapper {
            position: relative;
            width: 100%;
            height: 300px;
            border: 1px solid #333;
            background: rgba(10, 10, 10, 0.6);
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #flow-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .labels {
            display: none;
        }

        .scroll-indicator {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            opacity: 0.6;
            animation: bounce 2s infinite;
        }

        .scroll-indicator span {
            font-size: 0.8rem;
            font-family: var(--font-mono);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .scroll-indicator .arrow {
            font-size: 1.2rem;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateX(-50%) translateY(0);}
            40% {transform: translateX(-50%) translateY(-5px);}
            60% {transform: translateX(-50%) translateY(-2px);}
        }

    </style>
</head>
<body>
    <canvas id="bg-canvas"></canvas>
    <div class="scanlines"></div>
    <div class="vignette"></div>

    <section id="hero">
        <div class="container">
            <h1>OpenGuard</h1>
            <p>A guarding proxy for AI that applies security and privacy controls to LLM requests.</p>
            <code onclick="navigator.clipboard.writeText(this.innerText)">docker run ghcr.io/everlier/openguard:main</code>
        </div>
        <div class="scroll-indicator">
            <span>More</span>
            <div class="arrow">â†“</div>
        </div>
    </section>

    <section id="architecture">
        <div class="architecture-container">
            <div class="flow-header">
                <h2 style="margin: 0;">The Flow</h2>

                <!-- Toggle Switch -->
                <div class="toggle-container" onclick="toggleGuard()">
                    <div class="toggle-label">OpenGuard</div>
                    <div class="toggle-switch" id="guard-toggle">
                        <div class="toggle-track"></div>
                        <div class="toggle-thumb"></div>
                    </div>
                    <div class="status-label" id="guard-status">ENABLED</div>
                </div>
            </div>

            <div id="flow-wrapper">
                <canvas id="flow-canvas"></canvas>
                <div class="labels">
                    <div class="label-item">LLM</div>
                    <div class="label-item">Proxy</div>
                    <div class="label-item">App</div>
                    <div class="label-item">Env</div>
                </div>
            </div>
        </div>
    </section>

    <style>
        /* New Toggle Styles */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 15px;
            cursor: pointer;
            user-select: none;
            background: rgba(20, 20, 20, 0.8);
            padding: 10px 20px;
            border: 1px solid #333;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .toggle-container:hover {
            border-color: #666;
            background: rgba(30, 30, 30, 0.9);
        }

        .toggle-label {
            font-family: var(--font-pixel-grid);
            font-size: 1rem;
            color: #ccc;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-track {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #333;
            border-radius: 13px;
            transition: background 0.3s;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5);
        }

        .toggle-thumb {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: #888;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        /* Active State */
        .toggle-container.active .toggle-track {
            background: rgba(50, 255, 50, 0.2);
            border: 1px solid rgba(50, 255, 50, 0.5);
        }

        .toggle-container.active .toggle-thumb {
            left: 27px;
            background: #fff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .status-label {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: #666;
            min-width: 60px;
        }

        .toggle-container.active .status-label {
            color: #fff;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
        }
    </style>

    <script>
        const canvas = document.getElementById('bg-canvas');
        const ctx = canvas.getContext('2d');

        let width, height;

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resize);
        resize();

        // Grid properties
        const gridSize = 40;
        let offset = 0;
        const speed = 0.5;

        // Star/Paricle properties
        const stars = [];
        const numStars = 100;

        for(let i=0; i<numStars; i++) {
            stars.push({
                x: Math.random() * width,
                y: Math.random() * height,
                size: Math.random() * 2,
                opacity: Math.random(),
                speed: Math.random() * 0.5 + 0.1
            });
        }

        function drawGrid() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;

            // Perspective Grid
            // Imagine a floor plane moving towards us
            const horizon = height * 0.3; // Horizon line height
            const fov = 300;

            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            // Draw Stars (Background layer)
            // Reduced star count and opacity on mobile
            const isMobile = width < 600;
            const starOpacity = isMobile ? 0.15 : 0.3;

            ctx.fillStyle = '#fff';
            stars.forEach(star => {
                ctx.globalAlpha = star.opacity * starOpacity;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();

                // Move stars slowly up
                star.y -= star.speed;
                if(star.y < 0) {
                    star.y = height;
                    star.x = Math.random() * width;
                }
            });
            ctx.globalAlpha = 1;

            // Draw Floor Grid
            ctx.beginPath();

            // Vertical lines (converging)
            // We draw lines from the horizon to the bottom
            // We need to calculate where the lines should be to look like a floor

            const centerX = width / 2;

            // Draw a simple retro-wave style grid
            for (let x = -width; x < width * 2; x += gridSize) {
                // To make them converge, we draw from (x, bottom) to (centerX, horizon)
                // But let's do a strict perspective projection for "correctness"
                // or a simple artistic one.

                // Artistic "floor"
                ctx.moveTo(x, height);
                // Intersect with horizon at a vanishing point?
                // Let's just make them parallel but slanted?
                // No, perspective is better.

                // Calculate x position at bottom based on angle
                // Actually, let's keep it abstract: Just a 2D grid that rotates?
                // No, user asked for "Moving grid".

                // Simple perspective:
                // Lines radiate from (centerX, horizon)
                const spacing = 40;
                // We generate points along the bottom edge
                // And connect them to the vanishing point (centerX, horizon)
            }

            // Let's do a "Digital Tunnel" or "Floor" effect simpler.
            // Horizontal lines:
            // y position increases exponentially as it gets closer

            offset = (offset + speed) % gridSize;

            // Draw Horizontal Lines (Moving forward)
            for (let z = 0; z < height; z += gridSize) {
                // Perspective transform?
                // Visual approximation:
                // Just moving lines down the screen, but spacing increases?
                // Let's stick to a flat moving grid for "Schematic" look, matches Geist Pixel better.

                // Flat Grid (Schematic) - easier to read text over
                // Vertical
                /*
                for (let x = 0; x <= width; x += gridSize) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                }
                // Horizontal
                const yOffset = offset;
                for (let y = yOffset; y <= height; y += gridSize) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                }
                */
            }
            // OK, switching to the designed "Perspective Floor"

            const vanishingPointY = height * 0.2;
            const vanishingPointX = width / 2;

            // Draw Vertical Lines (Radiating)
            // We space them out at the bottom
            const numLines = 40;
            const bottomWidth = width * 4; // Extend beyond screen

            for(let i = 0; i <= numLines; i++) {
                const xBottom = (i / numLines) * bottomWidth - (bottomWidth - width)/2;
                ctx.moveTo(vanishingPointX, vanishingPointY);
                ctx.lineTo(xBottom, height);
            }

            // Draw Horizontal Lines (Approaching)
            // Their spacing should increase as they go down
            // z goes from far (0) to near (1)

            // Animation offset
            const time = Date.now() / 1000;
            const gridSpeed = 0.4;
            const gridOffset = (time * gridSpeed) % 1;

            for(let i = 0; i < 20; i++) {
                // Exponential spacing for perspective
                // base position
                let z = (i + gridOffset) / 20; // 0 to 1
                // Perspective mapping: y = y_vanish + d / (1-z)? or just simple pow
                // Simple power curve looks like perspective
                let y = vanishingPointY + (height - vanishingPointY) * Math.pow(z, 2);

                if (y > height) continue;
                if (y < vanishingPointY) continue;

                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
            }

            // Draw!
            ctx.strokeStyle = 'rgba(50, 255, 50, 0.08)'; // Tech Green, very transparent
            ctx.strokeStyle = 'rgba(237, 237, 237, 0.05)'; // Using variable fg color approx
            ctx.stroke();

            // Add a "Gradient Mask" so the grid fades out at the top
            const gradient = ctx.createLinearGradient(0, vanishingPointY, 0, height);
            gradient.addColorStop(0, 'rgba(10,10,10, 1)'); // Opaque black cover at top
            gradient.addColorStop(0.2, 'rgba(10,10,10, 0)'); // Transparent
            gradient.addColorStop(1, 'rgba(10,10,10, 0)');

            // Actually, better to just clip the drawing or clearRect?
            // Let's just draw a big black box over the top area to hide the vanishing point mess
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, vanishingPointY);
        }

        function animate() {
            drawGrid();
            requestAnimationFrame(animate);
        }

        animate();

        // --- GLOBAL STATE ---
        let isGuardEnabled = true;

        function toggleGuard() {
            isGuardEnabled = !isGuardEnabled;
            const container = document.querySelector('.toggle-container');
            const status = document.getElementById('guard-status');

            if (isGuardEnabled) {
                container.classList.add('active');
                status.innerText = 'ENABLED';
                status.style.color = '#fff';
            } else {
                container.classList.remove('active');
                status.innerText = 'DISABLED';
                status.style.color = '#666';
            }
        }

        // Init toggle state
        document.querySelector('.toggle-container').classList.add('active');


        // --- FLOW DIAGRAM ANIMATION ---
        function startFlowAnimation() {
            const flowCanvas = document.getElementById('flow-canvas');
            if (!flowCanvas) return;
            const flowCtx = flowCanvas.getContext('2d');

            let w, h;
            // State
            let particles = [];
            let effects = [];

            // Time-based animation variables
            let lastTime = 0;
            let spawnTimer = 0;
            let nextSpawnTime = 0.5; // Dynamic spawn interval

            function resizeFlow() {
                const rect = flowCanvas.parentElement.getBoundingClientRect();
                w = flowCanvas.width = rect.width;
                h = flowCanvas.height = rect.height;
            }
            window.addEventListener('resize', resizeFlow);
            resizeFlow();

            // Utilities
            function drawBox(x, y, width, height, label, color) {
                flowCtx.strokeStyle = color;
                flowCtx.lineWidth = 2;
                flowCtx.strokeRect(x - width/2, y - height/2, width, height);

                // Label inside
                flowCtx.fillStyle = color;
                flowCtx.font = '12px "Geist Mono", monospace';
                flowCtx.textAlign = 'center';
                flowCtx.textBaseline = 'middle';
                flowCtx.fillText(label, x, y);
            }

            function drawEye(x, y, radius, isOpen) {
                if (!isOpen) {
                    // Closed eye / Disabled
                    flowCtx.strokeStyle = '#333';
                    flowCtx.lineWidth = 1;
                    flowCtx.beginPath();
                    flowCtx.moveTo(x - radius, y);
                    flowCtx.lineTo(x + radius, y);
                    flowCtx.stroke();
                    return;
                }

                flowCtx.save();
                flowCtx.translate(x, y);

                // Outer
                flowCtx.strokeStyle = '#fff';
                flowCtx.lineWidth = 2;
                flowCtx.beginPath();
                flowCtx.moveTo(-radius, 0);
                flowCtx.quadraticCurveTo(0, -radius*0.7, radius, 0);
                flowCtx.quadraticCurveTo(0, radius*0.7, -radius, 0);
                flowCtx.stroke();

                // Pupil (Scanning)
                const time = Date.now() / 1000;
                const scanOffset = Math.sin(time * 3) * (radius * 0.3);

                flowCtx.fillStyle = '#fff';
                flowCtx.beginPath();
                flowCtx.arc(scanOffset, 0, radius * 0.25, 0, Math.PI * 2);
                flowCtx.fill();

                // Glow
                flowCtx.shadowBlur = 10;
                flowCtx.shadowColor = '#fff';
                flowCtx.fill();
                flowCtx.shadowBlur = 0;

                flowCtx.restore();
            }

            function update(timestamp) {
                if (!lastTime) lastTime = timestamp;
                const dt = (timestamp - lastTime) / 1000;
                lastTime = timestamp;

                flowCtx.clearRect(0, 0, w, h);

                const cy = h / 2;
                // Scale component size based on width
                const cw = Math.max(40, Math.min(60, w * 0.08));

                // Layout Positions equal spacing
                const margin = w * 0.1;
                const availableWidth = w - (margin * 2);

                // 4 components X positions
                const xLLM = margin;
                const xGuard = margin + (availableWidth * 0.33);
                const xHarness = margin + (availableWidth * 0.66);
                const xEnv = w - margin;

                // Requirement 1: Speed calculation (Env to LLM in 1.0s)
                // Distance = xEnv - xLLM
                // Speed = Distance / 1.0
                const travelDist = xEnv - xLLM;
                const refSpeed = travelDist / 1.0; // pixels per second

                // Requirement 3: Multiple Downstream LLMs
                // Define 3 LLM vertical positions
                const llmSpacing = cw * 1.5;
                const llmYs = [cy - llmSpacing, cy, cy + llmSpacing];

                // 1. Draw Static Architecture

                // Connection Lines
                flowCtx.strokeStyle = '#333';
                flowCtx.lineWidth = 2;
                flowCtx.setLineDash([5, 5]); // Dotted line for Harness

                // Env -> Harness
                flowCtx.beginPath();
                flowCtx.moveTo(xEnv, cy);
                flowCtx.lineTo(xHarness, cy);
                flowCtx.stroke();

                // Harness -> Guard -> LLMs
                // Draw lines from Harness (via Guard logic visual, but structurally implies connection)
                // Actually usually Harness -> Guard -> LLM
                // Let's draw Harness -> Guard
                flowCtx.beginPath();
                flowCtx.moveTo(xHarness, cy);
                flowCtx.lineTo(xGuard, cy);
                flowCtx.stroke();

                // Guard -> 3 LLMs
                // Fan out lines from Guard to each LLM
                llmYs.forEach(y => {
                    flowCtx.beginPath();
                    flowCtx.moveTo(xGuard, cy);
                    flowCtx.lineTo(xLLM, y);
                    flowCtx.stroke();
                });

                flowCtx.setLineDash([]); // Reset

                // Helper labels
                function drawBottomLabel(x, text) {
                    flowCtx.fillStyle = '#666';
                    flowCtx.font = '10px "Geist Mono", monospace';
                    flowCtx.textAlign = 'center';
                    flowCtx.textBaseline = 'bottom';
                    flowCtx.fillText(text, x, h - 10);
                }

                drawBottomLabel(xLLM, 'LLMs');
                drawBottomLabel(xGuard, 'PROXY');
                drawBottomLabel(xHarness, 'APP');
                drawBottomLabel(xEnv, 'ENV');

                // Draw Components

                // Environment (Right)
                drawBox(xEnv, cy, cw, cw, 'ENV', '#888');

                // Harness
                drawBox(xHarness, cy, cw, cw, 'APP', '#888');

                // 3 LLMs (Left)
                // We'll label them 1, 2, 3
                llmYs.forEach((y, i) => {
                     drawBox(xLLM, y, cw, cw, `LLM ${i+1}`, '#fff');
                });

                // Guard (Middle) - Eye
                flowCtx.fillStyle = '#0a0a0a';
                flowCtx.beginPath();
                flowCtx.arc(xGuard, cy, cw/2, 0, Math.PI*2);
                flowCtx.fill();
                drawEye(xGuard, cy, cw/2 - 5, isGuardEnabled);

                // 2. Logic & Particles

                // Requirement 2: Irregular Intervals / Bursts
                spawnTimer += dt;

                if (spawnTimer > nextSpawnTime) {
                    spawnTimer = 0;

                    // Determine next spawn time (Bursts)
                    // 30% chance of burst (very fast spawn), else normal random
                    if (Math.random() < 0.3) {
                        nextSpawnTime = 0.1; // Burst
                    } else {
                         // Normal: 0.2s to 0.8s (Average 0.5s)
                        nextSpawnTime = 0.2 + Math.random() * 0.6;
                    }

                    // Determine Payload
                    // 35% poison/malicious, 65% clean
                    const isPoison = Math.random() < 0.35;

                    particles.push({
                        id: Math.random(),
                        x: xEnv,
                        y: cy,
                        type: 'request', // request | response
                        payload: isPoison ? 'poison' : 'clean',
                        color: isPoison ? '#f00' : '#4f4', // Red or Green
                        size: 6,
                        vx: -refSpeed, // Requirement 1
                        vy: 0,
                        targetLLMIndex: -1, // Not assigned yet
                        state: 'alive'
                    });
                }

                // Update Loop
                particles.forEach(p => {
                    if (p.state === 'dead') return;

                    p.x += p.vx * dt;
                    p.y += p.vy * dt;

                    // --- INTERACTION LOGIC ---

                    // 1. Moving Left (Request: Env -> Harness -> Guard -> LLM)
                    if (p.vx < 0) {

                        // Passing Guard Region?
                        // We check if it crossed xGuard in this frame or is close
                        // Since we have variable speed, precise crossing check:
                        // prevX > xGuard && currX <= xGuard
                        // But simple distance check works if speed isn't insane compared to dt

                        // Check proximity to Guard for logic trigger
                        // Only trigger once: use a flag or check range narrowly
                        if (Math.abs(p.x - xGuard) < 10 && p.targetLLMIndex === -1) {

                            // Requirement 4: Block vs Clean
                            let blocked = false;

                            if (isGuardEnabled && p.payload === 'poison') {
                                // 50/50 Block or Clean
                                if (Math.random() < 0.5) {
                                    // BLOCK
                                    p.state = 'dead';
                                    blocked = true;
                                    // Effect
                                    effects.push({
                                        type: 'BLOCK',
                                        x: xGuard,
                                        y: cy,
                                        life: 0.5
                                    });
                                } else {
                                    // CLEAN
                                    p.payload = 'clean';
                                    p.color = '#4f4'; // Turn Green
                                    // Effect? small glint
                                }
                            }

                            if (!blocked) {
                                // Requirement 3: Route to specific LLM
                                // Pick random LLM 0, 1, 2
                                const targetIdx = Math.floor(Math.random() * 3);
                                p.targetLLMIndex = targetIdx;
                                const targetY = llmYs[targetIdx];

                                // Calculate VY to reach targetY at xLLM
                                // Time remaining = distance / speed
                                const distRemaining = Math.abs(xLLM - p.x); // p.x is approx xGuard
                                const timeRemaining = distRemaining / Math.abs(p.vx);

                                if (timeRemaining > 0) {
                                    p.vy = (targetY - p.y) / timeRemaining;
                                }
                            }
                        }

                        // Reaching LLM?
                        if (p.x <= xLLM) {
                            p.state = 'dead'; // Consumed request

                            // Determine Response
                            // If payload is poison (passed through disabled guard), interaction is bad
                            // If payload is clean (was clean or filtered), interaction is good

                            let isMalice = (p.payload === 'poison');
                            let responseColor = isMalice ? '#b0f' : '#fff'; // Purple (Malice) or White (Normal)

                            // Effect at specific LLM
                            const hitY = (p.targetLLMIndex >= 0) ? llmYs[p.targetLLMIndex] : cy;

                            effects.push({
                                type: 'FLASH',
                                x: xLLM,
                                y: hitY,
                                color: responseColor,
                                life: 0.3
                            });

                            // Spawn Response moving Right
                            // Return from same Y

                            // 2-Phase Return: 1. To Proxy, 2. To Env
                            // Calculate VY to hit Proxy (xGuard, cy) first
                            const distToGuard = xGuard - xLLM;
                            // Time needed to reach xGuard at current speed
                            const timeToGuard = distToGuard / refSpeed;

                            let vyToGuard = 0;
                            if (timeToGuard > 0) {
                                vyToGuard = (cy - hitY) / timeToGuard;
                            }

                            particles.push({
                                id: Math.random(),
                                x: xLLM,
                                y: hitY,
                                type: 'response',
                                payload: isMalice ? 'malice' : 'clean',
                                color: responseColor,
                                size: 6,
                                vx: refSpeed, // Move Right
                                vy: vyToGuard, // Target the Guard
                                state: 'alive'
                            });
                        }
                    }
                    // 2. Moving Right (Response: LLM -> ... -> Env)
                    else if (p.vx > 0) {
                         // Passing Guard? Snap to center line and move straight to Env
                         if (p.x >= xGuard) {
                             // If we have vertical velocity, we just arrived/crossed.
                             // Snap to exact center (xGuard, cy) for this frame to ensure
                             // visual "pass through" through the eye.
                             if (p.vy !== 0) {
                                 p.x = xGuard;
                                 p.y = cy;
                                 p.vy = 0;
                             } else {
                                 // Already moving straight to Env
                                 p.y = cy;
                             }
                         }

                         // Reaching Env?
                         if (p.x >= xEnv) {
                            p.state = 'dead';

                            if (p.payload === 'malice') {
                                // DAMAGE!
                                effects.push({
                                    type: 'BREACH',
                                    x: xEnv,
                                    y: cy,
                                    life: 0.5
                                });
                            }
                         }
                    }

                    // Draw Particle
                    if (p.state === 'alive') {
                        flowCtx.fillStyle = p.color;
                        flowCtx.beginPath();
                        // Diamond shape
                        flowCtx.moveTo(p.x, p.y - p.size);
                        flowCtx.lineTo(p.x + p.size, p.y);
                        flowCtx.lineTo(p.x, p.y + p.size);
                        flowCtx.lineTo(p.x - p.size, p.y);
                        flowCtx.fill();
                    }
                });

                // Update Effects
                effects.forEach(e => {
                    e.life -= dt;
                    if (e.type === 'BLOCK' || e.type === 'BREACH') {
                        e.y -= 20 * dt; // Float up
                    }
                });
                effects = effects.filter(e => e.life > 0);

                // Draw effects
                effects.forEach(e => {
                    const alpha = Math.max(0, e.life / 0.5);
                    flowCtx.save();
                    flowCtx.globalAlpha = alpha;

                    if (e.type === 'BLOCK') {
                        flowCtx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                        flowCtx.beginPath();
                        flowCtx.arc(e.x, e.y, 20, 0, Math.PI*2);
                        flowCtx.fill();
                        flowCtx.fillStyle = '#f00';
                        flowCtx.textAlign = 'center';
                        flowCtx.font = '10px monospace';
                        flowCtx.fillText('BLOCKED', e.x, e.y - 25);
                    }
                    else if (e.type === 'FLASH') {
                        flowCtx.fillStyle = e.color;
                        flowCtx.fillRect(e.x - cw/2, e.y - cw/2, cw, cw);
                    }
                    else if (e.type === 'BREACH') {
                        flowCtx.fillStyle = 'rgba(180, 0, 255, 0.4)';
                        flowCtx.beginPath();
                        flowCtx.arc(e.x, e.y, 30, 0, Math.PI*2);
                        flowCtx.fill();
                        flowCtx.fillStyle = '#b0f';
                        flowCtx.textAlign = 'center';
                        flowCtx.fillText('!! BREACH !!', e.x, e.y - 35);
                    }

                    flowCtx.restore();
                });

                // Cleanup
                particles = particles.filter(p => p.state === 'alive');

                requestAnimationFrame(update);
            }
            requestAnimationFrame(update);
        }

        startFlowAnimation();

        // Font Toggle Animation for Title
        function startFontToggle() {
            const h1 = document.querySelector('h1');
            if (!h1) return;

            const fonts = [
                'var(--font-pixel-circle)',
                'var(--font-pixel-grid)',
                'var(--font-pixel-line)',
                'var(--font-pixel-square)',
                'var(--font-pixel-triangle)'
            ];

            let index = 1; // Starts with Grid (index 1) in CSS

            setInterval(() => {
                index = (index + 1) % fonts.length;
                h1.style.fontFamily = fonts[index];
            }, 1000);
        }

        startFontToggle();
    </script>
</body>
</html>
