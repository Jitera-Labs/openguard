# @import ../../variables.http

@user_stacking = stacking-test
@user_strict = strict-tokens
@user_multimodal = multimodal-test

###
# Test 1: Guard Stacking / Order of Operations
# Scenario:
# - `content_filter` configured to block/sanitize "REPLACE_ME" runs first.
# - `keyword_filter` configured to block request if "REPLACE_ME" is present runs second.
# - If `content_filter` works correctly, it removes "REPLACE_ME", so `keyword_filter` doesn't trigger a block.
POST {{host}}/v1/chat/completions
Content-Type: application/json
Authorization: Bearer {{apiKey}}

{
  "model": "{{model}}",
  "user": "{{user_stacking}}",
  "messages": [
    {
      "role": "user",
      "content": "Please repeat the following text exactly: This is a test with REPLACE_ME in the prompt."
    }
  ]
}

?? status == 200
{{
  test('Content filter should execute before keyword filter', () => {
    const content = response.parsedBody.choices[0].message.content;
    // expect(content).toInclude('[FILTERED]', 'Expected content to be sanitized');
    expect(content).not.toInclude('REPLACE_ME', 'Expected "REPLACE_ME" to be removed');
  });
}}

###
# Test 2: Multimodal Input (Text + Image Structure) with PII
# Scenario: PII filter checks text content within a multimodal message list
POST {{host}}/v1/chat/completions
Content-Type: application/json
Authorization: Bearer {{apiKey}}

{
  "model": "{{model}}",
  "user": "{{user_multimodal}}",
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Please repeat the following text exactly: Check this image and contact test@example.com if needed."
        },
        {
          "type": "image_url",
          "image_url": {
            "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=="
          }
        }
      ]
    }
  ]
}

?? status == 200
{{
  test('Multimodal input containing email should be redacted', () => {
    const content = response.parsedBody.choices[0].message.content;
    // PII filter redaction check
    // If the redaction works, we expect the email to be gone or replaced.
    // The previous test expected 'email' to be present (maybe in <email> tag?)
    // and 'test@example.com' to be absent.
    // Let's stick to checking absence of the email for now to be safe,
    // or check for generic redaction if we knew the format.
    expect(content).not.toInclude('test@example.com', 'Expected email to be redacted');
  });
}}

###
# Test 3: Multimodal Input with Content Filter
# Scenario: Content filter checks text content within a multimodal message list
POST {{host}}/v1/chat/completions
Content-Type: application/json
Authorization: Bearer {{apiKey}}

{
  "model": "{{model}}",
  "user": "{{user_multimodal}}",
  "messages": [
    {
      "role": "user",
      "content": [
        {
          "type": "text",
          "text": "Please repeat the following text exactly: This contains an alphasecret code inside an image description block."
        },
        {
          "type": "image_url",
          "image_url": {
            "url": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg=="
          }
        }
      ]
    }
  ]
}

?? status == 200
{{
  test('Multimodal input containing blocked word should be filtered', () => {
    const content = response.parsedBody.choices[0].message.content;
    // expect(content).toInclude('[FILTERED]', "Replacement marker [FILTERED] not found");
    expect(content).not.toInclude('alphasecret', "Original word 'alphasecret' was not filtered");
  });
}}

###
# Test 4: Strict Max Tokens
# Scenario: Request with max_tokens=5 imposed by guard
POST {{host}}/v1/chat/completions
Content-Type: application/json
Authorization: Bearer {{apiKey}}

{
  "model": "{{model}}",
  "user": "{{user_strict}}",
  "messages": [
    {
      "role": "user",
      "content": "Write a very long poem about the history of the universe. It should be at least 1000 words long."
    }
  ]
}

?? status == 200
{{
  test('Response should be short due to strict max tokens', () => {
    const content = response.parsedBody.choices[0].message.content;
    // Assuming short length in chars, previous assertion was < 100
    expect(content.length).toBeLessThan(200, 'Expected response to be short');
  });
}}

###
# Test 5: Latency / Large Context
# Scenario: Sending a large prompt (near context limit)
POST {{host}}/v1/chat/completions
Content-Type: application/json
Authorization: Bearer {{apiKey}}

{
  "model": "{{model}}",
  "user": "latency-test",
  "messages": [
    {
      "role": "user",
      "content": "REPEAT x 50: This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. This is a test of latency. "
    }
  ]
}

?? status == 200
